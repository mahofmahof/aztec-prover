<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Aztec Prover Rewards Claimer</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; margin: 20px; max-width: 980px; }
    .row { display: flex; gap: 12px; flex-wrap: wrap; align-items: flex-end; }
    .card { border: 1px solid #ddd; border-radius: 10px; padding: 12px; margin: 12px 0; }
    input, button { padding: 8px; border-radius: 8px; border: 1px solid #ccc; }
    button { cursor: pointer; }
    button:disabled { cursor: not-allowed; opacity: 0.55; }
    table { width: 100%; border-collapse: collapse; }
    th, td { border-bottom: 1px solid #eee; padding: 8px; text-align: left; }
    .muted { color: #666; font-size: 0.92em; }
    .ok { color: #0a7; font-weight: 700; }
    .bad { color: #c22; font-weight: 700; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas; font-size: 0.92em; }
    .pill { display:inline-block; padding: 2px 8px; border-radius: 999px; border:1px solid #ddd; }
  </style>
</head>
<body>
  <h1>Aztec Prover Rewards Claimer</h1>
  <div class="muted">GitHub Pages static app — private key yok, sadece MetaMask imzalar.</div>

  <div class="card">
    <div class="row">
      <div>
        <div class="muted">ROLLUP (static)</div>
        <input id="rollup" size="48" value="0x603bb2c05D474794ea97805e8De69bCcFb3bCA12" readonly />
      </div>
      <div style="flex:1; min-width: 320px;">
        <div class="muted">PROVER (reward owner) — user input</div>
        <input id="prover" size="48" placeholder="0x..." value="" />
        <div id="proverHint" class="muted mono" style="margin-top:6px;">—</div>
      </div>
    </div>

    <div class="row" style="margin-top:10px;">
      <div>
        <div class="muted">RPC (read + estimate)</div>
        <input id="rpc" size="48" value="https://ethereum-rpc.publicnode.com" />
      </div>
      <div>
        <div class="muted">Epoch range</div>
        <input id="startEpoch" size="8" value="1" />
        <input id="endEpoch" size="8" value="4000" />
      </div>
      <div>
        <div class="muted">Batch size</div>
        <input id="batch" size="6" value="50" />
      </div>
    </div>

    <div class="row" style="margin-top:10px;">
      <button id="connect">Connect MetaMask</button>
      <div class="mono muted">Connected: <span id="connected" class="pill">-</span></div>
      <div class="mono muted">Match: <span id="match" class="pill">-</span></div>
    </div>

    <div class="row" style="margin-top:10px;">
      <button id="scan">Scan Rewards</button>
      <button id="estimate" disabled>Estimate Claim Cost</button>
      <button id="claim" disabled>Claim Selected</button>
    </div>

    <div class="muted" style="margin-top:10px;">
      Not: Claim/Estimate için MetaMask bağlı adresin <b>PROVER ile aynı</b> olması gerekir (kontrat genelde bunu enforce eder).
    </div>
  </div>

  <div class="card">
    <h3>Summary</h3>
    <div id="status" class="mono muted">Ready.</div>

    <div class="row">
      <div class="card" style="flex:1;">
        <div class="muted">Total reward (ETH)</div>
        <div id="totalReward" class="mono">-</div>
      </div>
      <div class="card" style="flex:1;">
        <div class="muted">Estimated claim cost (ETH)</div>
        <div id="claimCost" class="mono">-</div>
      </div>
      <div class="card" style="flex:1;">
        <div class="muted">Profit check</div>
        <div id="profit" class="mono">-</div>
      </div>
    </div>

    <div class="row">
      <div style="flex:1;">
        <div class="muted">Avg “Submit Epoch proof” fee per epoch (ETH) — manuel gir</div>
        <input id="avgSubmitFee" size="12" value="0.00030" />
      </div>
      <div style="flex:1;">
        <div class="muted">Estimated net (reward - submitFees - claimCost)</div>
        <div id="net" class="mono">-</div>
      </div>
    </div>
  </div>

  <div class="card">
    <h3>Epochs with rewards</h3>
    <div class="muted">Scan sonrası reward>0 olan epochlar listelenir. Claim etmek istediklerini seç.</div>
    <table>
      <thead>
        <tr>
          <th>Select</th>
          <th>Epoch</th>
          <th>Reward (ETH)</th>
        </tr>
      </thead>
      <tbody id="rows"></tbody>
    </table>
  </div>

  <script type="module">
    import { ethers } from "https://cdn.jsdelivr.net/npm/ethers@6.13.4/+esm";

    const ABI = [
      "function getSpecificProverRewardsForEpoch(uint256 epoch, address prover) view returns (uint256)",
      "function claimProverRewards(address _coinbase, uint256[] _epochs)"
    ];

    const el = (id) => document.getElementById(id);
    const status = (s) => el("status").textContent = s;

    let providerRead = null;     // JSON-RPC provider for reads/estimates
    let browserProvider = null;  // MetaMask provider
    let signer = null;
    let account = null;

    let found = []; // {epoch, wei, eth}

    function toEth(wei) { return Number(ethers.formatEther(wei)); }

    function normalizeAddress(input) {
      const s = (input || "").trim();
      if (!s) return "";
      // lower -> checksum
      return ethers.getAddress(s.toLowerCase());
    }

    function getProverOrThrow() {
      const raw = el("prover").value;
      try {
        const addr = normalizeAddress(raw);
        el("prover").value = addr; // normalize in UI
        el("proverHint").innerHTML = `<span class="ok">OK</span> <span class="mono">${addr}</span>`;
        return addr;
      } catch (e) {
        el("proverHint").innerHTML = `<span class="bad">Invalid address</span> <span class="mono">${(e?.message || e)}</span>`;
        throw new Error("Invalid PROVER address.");
      }
    }

    function updateMatchUI() {
      const connected = account ? normalizeAddress(account) : "";
      el("connected").textContent = connected || "-";

      let prover = "";
      try { prover = normalizeAddress(el("prover").value); } catch { prover = ""; }

      const ok = connected && prover && (connected === prover);

      if (!connected) {
        el("match").innerHTML = `<span class="muted">-</span>`;
      } else if (!prover) {
        el("match").innerHTML = `<span class="bad">PROVER invalid</span>`;
      } else if (ok) {
        el("match").innerHTML = `<span class="ok">YES</span>`;
      } else {
        el("match").innerHTML = `<span class="bad">NO</span>`;
      }

      // Claim/estimate only if connected + match + have epochs selected (checked later)
      el("estimate").disabled = !(account && ok);
      el("claim").disabled = !(account && ok);
    }

    function getSelectedEpochs() {
      const checks = document.querySelectorAll("input[data-epoch]:checked");
      return Array.from(checks).map(c => Number(c.getAttribute("data-epoch")));
    }

    function sumSelectedRewards() {
      const selected = new Set(getSelectedEpochs());
      let total = 0;
      for (const r of found) if (selected.has(r.epoch)) total += r.eth;
      return total;
    }

    function renderRows() {
      const tbody = el("rows");
      tbody.innerHTML = "";
      for (const r of found) {
        const tr = document.createElement("tr");
        tr.innerHTML = `
          <td><input type="checkbox" data-epoch="${r.epoch}" checked /></td>
          <td class="mono">${r.epoch}</td>
          <td class="mono">${r.eth.toFixed(8)}</td>
        `;
        tbody.appendChild(tr);
      }
      tbody.querySelectorAll("input[type=checkbox]").forEach(cb => {
        cb.addEventListener("change", () => {
          updateSummary();
        });
      });
    }

    function updateSummary(claimCostEth = null) {
      const totalReward = sumSelectedRewards();
      el("totalReward").textContent = totalReward ? totalReward.toFixed(8) : "-";

      const avgSubmit = Number(el("avgSubmitFee").value || "0");
      const submitFees = avgSubmit * getSelectedEpochs().length;

      if (claimCostEth != null) {
        el("claimCost").textContent = claimCostEth.toFixed(8);
        const net = totalReward - submitFees - claimCostEth;
        el("net").textContent = net.toFixed(8);

        if (net > 0) {
          el("profit").innerHTML = `<span class="ok">NET +${net.toFixed(8)} ETH</span>`;
        } else {
          el("profit").innerHTML = `<span class="bad">NET ${net.toFixed(8)} ETH</span>`;
        }
      } else {
        el("claimCost").textContent = "-";
        el("net").textContent = "-";
        el("profit").textContent = "-";
      }
    }

    async function initReadProvider() {
      const rpc = el("rpc").value.trim();
      providerRead = new ethers.JsonRpcProvider(rpc);
      return providerRead;
    }

    // Normalize prover on input (but don't spam errors)
    el("prover").addEventListener("blur", () => {
      try { getProverOrThrow(); } catch {}
      updateMatchUI();
    });
    el("prover").addEventListener("input", () => updateMatchUI());

    el("connect").addEventListener("click", async () => {
      if (!window.ethereum) {
        alert("MetaMask bulunamadı.");
        return;
      }
      browserProvider = new ethers.BrowserProvider(window.ethereum);
      await browserProvider.send("eth_requestAccounts", []);
      signer = await browserProvider.getSigner();
      account = await signer.getAddress();
      status("Connected: " + account);

      // Normalize prover + enforce rule
      try { getProverOrThrow(); } catch {}
      updateMatchUI();
    });

    el("scan").addEventListener("click", async () => {
      try {
        status("Preparing provider...");
        await initReadProvider();

        const rollup = el("rollup").value.trim();
        const prover = getProverOrThrow();
        const startEpoch = Number(el("startEpoch").value);
        const endEpoch = Number(el("endEpoch").value);
        const batch = Math.max(1, Number(el("batch").value));

        if (!Number.isFinite(startEpoch) || !Number.isFinite(endEpoch) || startEpoch < 0 || endEpoch < startEpoch) {
          throw new Error("Invalid epoch range.");
        }

        const c = new ethers.Contract(rollup, ABI, providerRead);

        found = [];
        status(`Scanning ${startEpoch}..${endEpoch} (batch=${batch}) ...`);

        for (let i = startEpoch; i <= endEpoch; i += batch) {
          const hi = Math.min(endEpoch, i + batch - 1);
          const calls = [];
          for (let e = i; e <= hi; e++) calls.push(c.getSpecificProverRewardsForEpoch(e, prover));
          const res = await Promise.all(calls);

          for (let idx = 0; idx < res.length; idx++) {
            const epoch = i + idx;
            const wei = res[idx];
            if (wei !== 0n) found.push({ epoch, wei, eth: toEth(wei) });
          }
          status(`Scanned up to ${hi}. Found=${found.length}`);
        }

        found.sort((a,b) => a.epoch - b.epoch);
        renderRows();
        updateSummary();
        status(`Done. Found ${found.length} epochs with rewards.`);
        updateMatchUI();
      } catch (e) {
        console.error(e);
        status("Error: " + (e?.message || e));
      }
    });

    el("estimate").addEventListener("click", async () => {
      try {
        if (!providerRead) await initReadProvider();

        const rollup = el("rollup").value.trim();
        const prover = getProverOrThrow();

        if (!signer || !account) { alert("Önce Connect MetaMask."); return; }

        const connected = normalizeAddress(account);
        if (connected !== prover) {
          updateMatchUI();
          throw new Error(`Connected wallet must equal PROVER. Connected=${connected} PROVER=${prover}`);
        }

        const epochs = getSelectedEpochs();
        if (!epochs.length) { alert("Seçili epoch yok."); return; }

        const c = new ethers.Contract(rollup, ABI, providerRead);

        // IMPORTANT: coinbase = connected (same as prover)
        status("Estimating gas...");
        const gas = await c.claimProverRewards.estimateGas(connected, epochs);

        const fee = await providerRead.getFeeData();
        const maxFeePerGas = fee.maxFeePerGas ?? fee.gasPrice;
        if (!maxFeePerGas) throw new Error("Fee data unavailable (maxFeePerGas/gasPrice).");

        const costWei = gas * maxFeePerGas;
        const costEth = Number(ethers.formatEther(costWei));

        status(`Estimated gas=${gas.toString()} maxFeePerGas=${maxFeePerGas.toString()}`);
        updateSummary(costEth);
      } catch (e) {
        console.error(e);
        status("Error: " + (e?.message || e));
      }
    });

    el("claim").addEventListener("click", async () => {
      try {
        if (!signer || !account) { alert("Önce Connect MetaMask."); return; }

        const rollup = el("rollup").value.trim();
        const prover = getProverOrThrow();

        const connected = normalizeAddress(account);
        if (connected !== prover) {
          updateMatchUI();
          throw new Error(`Connected wallet must equal PROVER. Connected=${connected} PROVER=${prover}`);
        }

        const epochs = getSelectedEpochs();
        if (!epochs.length) { alert("Seçili epoch yok."); return; }

        const c = new ethers.Contract(rollup, ABI, signer);

        status("Sending claim tx (MetaMask) ...");
        // coinbase = connected (same as prover)
        const tx = await c.claimProverRewards(connected, epochs);
        status("Tx sent: " + tx.hash);

        const rcpt = await tx.wait();
        status("Mined ✅: " + rcpt.transactionHash);
      } catch (e) {
        console.error(e);
        status("Error: " + (e?.message || e));
      }
    });

    el("avgSubmitFee").addEventListener("input", () => updateSummary());

    // initial normalize hint
    try { getProverOrThrow(); } catch {}
    updateMatchUI();
  </script>
</body>
</html>
